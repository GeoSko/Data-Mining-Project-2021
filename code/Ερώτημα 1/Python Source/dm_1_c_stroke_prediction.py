# -*- coding: utf-8 -*-
"""DM_1_C_stroke_prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fXl8kXKV9X3pCWRHAKuZBwvygKMPTp5m
"""

#Import libraries
import pandas as pd
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn import preprocessing, metrics
from sklearn.metrics import classification_report
import seaborn as sns
from sklearn.utils import shuffle
from sklearn.model_selection import GridSearchCV
from imblearn.over_sampling import RandomOverSampler, SMOTE, ADASYN

#Initialize a list for datasets, models, and all the training/testing sets

df, models , X, y, X_train, X_naive_OS, X_SMOTE, X_ADASYN, X_test, y_train, y_naive_OS, y_SMOTE, y_ADASYN, y_test, y_pred, y_pred_training = ([] for i in range(16))

# Load all the processed datasets in the dataset list
for id in range(5):
  df.append(pd.read_csv(f"drive/MyDrive/DataMining/healthcare_processed_datasets/df{id+1}.csv", index_col=[0]))
  X.append(pd.get_dummies(df[id],drop_first=True).drop(['id','stroke'], axis=1))
  # df[id] = df[id].sample(frac=1)
  y.append(df[id].stroke)
  X_train.append(None)
  X_naive_OS.append(None)
  X_SMOTE.append(None)
  X_ADASYN.append(None)
  X_test.append(None)
  y_train.append(None)
  y_naive_OS.append(None)
  y_SMOTE.append(None)
  y_ADASYN.append(None)
  y_test.append(None)
  y_pred.append(None)
  y_pred_training.append(None)

df[3]['stroke'].value_counts()

# Input/output arrays and train test split
ros = RandomOverSampler(random_state=0)
for id in range(5):
  X_train[id], X_test[id], y_train[id], y_test[id] = train_test_split( X[id], y[id], test_size=0.25, random_state=0)
  X_naive_OS[id], y_naive_OS[id] = ros.fit_resample(X_train[id], y_train[id])
  X_SMOTE[id], y_SMOTE[id] = SMOTE(random_state= 0, sampling_strategy='minority', k_neighbors=30).fit_resample(X_train[id], y_train[id])
  X_ADASYN[id], y_ADASYN[id] = ADASYN(random_state= 0, sampling_strategy='minority', n_neighbors=10).fit_resample(X_train[id], y_train[id])

# Initial Model fitting, prediction and evaluation
# ORIGINAL
for id in range(5):
  models.append(RandomForestClassifier(random_state=0))
  models[id].fit(X_train[id], y_train[id])
  y_pred[id] = models[id].predict(X_test[id])

  y_pred_training[id] = models[id].predict(X_train[id])

  # print(f"##################### MODEL {id+1} TRAINING SET #########################")
  # print(classification_report(y_train[id], y_pred_training[id], target_names=['NO STROKE', 'STROKE']))

  print(f"##################### MODEL {id+1} TEST SET #########################")
  print(classification_report(y_test[id], y_pred[id], target_names=['NO STROKE', 'STROKE']))

# Initial Model fitting, prediction and evaluation
# NAIVE OS
for id in range(5):
  models.append(RandomForestClassifier(random_state=0))
  models[id].fit(X_naive_OS[id], y_naive_OS[id])
  y_pred[id] = models[id].predict(X_test[id])

  # y_pred_training[id] = models[id].predict(X_train[id])

  # print(f"##################### MODEL {id+1} TRAINING SET #########################")
  # print(classification_report(y_train[id], y_pred_training[id], target_names=['NO STROKE', 'STROKE']))

  print(f"##################### MODEL {id+1} #########################")
  print(classification_report(y_test[id], y_pred[id], target_names=['NO STROKE', 'STROKE']))

# Initial Model fitting, prediction and evaluation
# SMOTE
for id in range(5):
  models.append(RandomForestClassifier(random_state=0))
  models[id].fit(X_SMOTE[id], y_SMOTE[id])
  y_pred[id] = models[id].predict(X_test[id])

  # y_pred_training[id] = models[id].predict(X_train[id])

  # print(f"##################### MODEL {id+1} TRAINING SET #########################")
  # print(classification_report(y_train[id], y_pred_training[id], target_names=['NO STROKE', 'STROKE']))

  print(f"##################### MODEL {id+1} #########################")
  print(classification_report(y_test[id], y_pred[id], target_names=['NO STROKE', 'STROKE']))

# Initial Model fitting, prediction and evaluation
# ADASYN
for id in range(5):
  models.append(RandomForestClassifier(random_state=0))
  models[id].fit(X_ADASYN[id], y_ADASYN[id])
  y_pred[id] = models[id].predict(X_test[id])

  # y_pred_training[id] = models[id].predict(X_train[id])

  # print(f"##################### MODEL {id+1} TRAINING SET #########################")
  # print(classification_report(y_train[id], y_pred_training[id], target_names=['NO STROKE', 'STROKE']))

  print(f"##################### MODEL {id+1} #########################")
  print(classification_report(y_test[id], y_pred[id], target_names=['NO STROKE', 'STROKE']))

# Final model input/output arrays/vectors
X_train_final = X_naive_OS[2]
X_test_final = X_test[2]
y_train_final = y_naive_OS[2]
y_test_final = y_test[2]

parameters = {
    'n_estimators': (10,25,50,75,100),
    'criterion':('gini', 'entropy'),
    'max_depth': (3,7,18),
    'max_features':('auto','sqrt', 'log2'),
    'min_samples_split':(2,4,6),
    'class_weight': ('balanced', 'balanced_subsample', None)
    }

RF_grid = GridSearchCV(RandomForestClassifier(n_jobs=-1,oob_score=False), param_grid = parameters, cv=3, verbose=True, scoring='recall')

RF_grid_model = RF_grid.fit(X_train_final, y_train_final)

RF_grid_model.best_estimator_

RF_grid_model.best_score_

RF_Model = RandomForestClassifier(bootstrap=True, ccp_alpha=0.0, class_weight='balanced',
                       criterion='gini', max_depth=18, max_features='auto',
                       max_leaf_nodes=None, max_samples=None,
                       min_impurity_decrease=0.0, min_impurity_split=None,
                       min_samples_leaf=1, min_samples_split=2,
                       min_weight_fraction_leaf=0.0, n_estimators=10, n_jobs=-1,
                       oob_score=False, random_state=None, verbose=0,
                       warm_start=False)

RF_Model.fit(X_train_final, y_train_final)
y_pred_final = RF_Model.predict(X_test_final)
print(f"##################### Final Model #########################")
print(classification_report(y_test_final, y_pred_final, target_names=['NO STROKE', 'STROKE']))